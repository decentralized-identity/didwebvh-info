{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to did:webvh","text":"<p>The <code>did:webvh</code> DID Method (<code>did:web</code> + Verifiable History) was developed with the aim of enabling greater trust and security  than <code>did:web</code> without compromising the simplicity of <code>did:web</code>. Core features of the <code>did:webvh</code> method that complement <code>did:web</code> include:</p> <ul> <li>DID-to-HTTPS transformation that is the same as <code>did:web</code>.</li> <li>A Verifiable History: The ability to resolve the full history of the DID using a verifiable chain of   updates to the DIDDoc from genesis to deactivation.</li> <li>A Self-Certifying Identifier (SCID): The SCID, globally unique and   embedded in the DID, is derived from the initial DID log entry. It ensures the integrity   of the DID's history mitigating the risk of attackers creating a new object with   the same identifier.</li> <li>Authorized Keys: DIDDoc updates contain a proof signed by the DID Controllers authorized to   update the DID.</li> <li>Pre-rotation Keys (optional): The mechanism for publishing pre-rotation keys prevents the loss of   control of a DID in cases where an active private key is compromised.</li> <li>Witnesses (optional): The mechanism for having witnesses enables the collaborative   approval of updates to the DID by a DID Controller before publication.</li> <li>DID Portability (optional): The mechanism for enabling portability allows   the DID's web location to be moved and the DID string to be updated, both while retaining   a connection to the predecessor DID(s) and preserving the DID's verifiable history.</li> </ul> <p>In addition, the <code>did:webvh</code> method supports:</p> <ul> <li>A DID URL path handling that defaults (but can be overridden) to automatically   resolving <code>&lt;did&gt;/path/to/file</code> by using a comparable DID-to-HTTPS translation   as for the DIDDoc.</li> <li>A DID URL path <code>&lt;did&gt;/whois</code> that defaults to automatically returning (if   published by the [[ref: DID controller]]) a [[ref: Verifiable Presentation]]   containing [[ref: Verifiable Credentials]] with the DID as the   <code>credentialSubject</code>, signed by the DID. It draws inspiration from the   traditional WHOIS protocol [[spec:rfc3912]], offering an easy-to-use,   decentralized, trust registry.</li> <li>High Assurance DIDs with DNS mechanism that is the same as used for <code>did:web</code>.</li> </ul> <p>The <code>did:webvh</code> specification and based on it, the implementer's guide, were developed in parallel with the development of two proof of concept implementations. The specification/implementation interplay helped immensely in defining a practical, intuitive, straightforward, DID method. The existing implementations of the <code>did:webvh</code> DID Method are listed in the Implementers Guide. The current implementations range from around 1500 to 2000 lines of code.</p> <p>An example of a <code>did:webvh</code> evolving through a series of versions can be seen in the did:webvh Examples included on this site.</p>"},{"location":"agenda/","title":"Work Item Meetings","text":"<p>The <code>did:webvh</code> Work Item group at DIF meets every second Thursday at 9:00 Pacific / 18:00 Central Europe. The following is the conference call information, meeting schedule, and rolling agenda.</p>"},{"location":"didwebvh-server/","title":"did:webvh Web Server","text":""},{"location":"didwebvh-server/#a-web-server-for-publishing-didwebvh-and-didweb-dids","title":"A Web Server for publishing did:webvh (and did:web) DIDs","text":"<p>This server is built with the FastAPI framework.</p> <p>The did:webvh spec: https://identity.foundation/didwebvh</p>"},{"location":"didwebvh-server/#abstract","title":"Abstract","text":"<p>This server is for issuing clients to deposit their did documents, did logs and other objects.</p> <p>Having a separate server to deposit verification material will ensure that signing material is isolated and provide a more secured architecture.</p> <p>This also enables system architects to create rigid governance rules around publishing DID documents and related resources through endorsement.</p>"},{"location":"didwebvh-server/#how-it-works","title":"How it works","text":"<p>For a demonstration, please see the did:webvh Server demo directory</p> <ul> <li>An issuer requests an identifier location from the server.<ul> <li>The server returns a configuration if the location is available.</li> </ul> </li> <li>The issuer generates a verification method and signs a did document with it.<ul> <li>Using the provided proof configuration from the server.</li> </ul> </li> <li>The issuer request an endorser signature.<ul> <li>Using the provided proof configuration from the server.</li> </ul> </li> <li>The issuer sends this request back to the server.</li> </ul>"},{"location":"didwebvh-server/#registering-a-new-did","title":"Registering a new DID","text":"<pre><code>sequenceDiagram\n    participant did:webvh Web Server\n    participant Issuer Client\n    participant Endorser Agent\n    Issuer Client-&gt;&gt;did:webvh Web Server: Request an identifier namespace.\n    Trust did:webvh Web Server-&gt;&gt;Issuer Client: Provide a DID document and a proof configuration.\n    Issuer Client-&gt;&gt;Issuer Client: Create new verification method.\n    Issuer Client-&gt;&gt;Issuer Client: Sign DID document.\n    Issuer Client-&gt;&gt;Endorser Agent: Request endorser signature.\n    Endorser Agent-&gt;&gt;Endorser Agent: Verify and sign DID document.\n    Endorser Agent-&gt;&gt;Issuer Client: Return endorsed DID document.\n    Issuer Client-&gt;&gt;did:webvh Web Server: Send endorsed DID document.\n    Trust DID Web Server-&gt;&gt;did:webvh Web Server: Verify endorsed DID document.</code></pre>"},{"location":"didwebvh-server/#roadmap","title":"Roadmap","text":"<ul> <li>DID log support</li> <li>whois VP support</li> <li>AnonCreds objects support</li> <li>Status lists support</li> </ul> <pre><code>In a web where trust is born anew,\nDecentralized keys unlock our view.\nWe shape the code, and break the chain,\nTrust in our hands will always reign.\n</code></pre>"},{"location":"example/","title":"did:webvh DID Log Example","text":"<p>The following covers the evolution of a <code>did:webvh</code> from inception through a second DID log entry, showing the DID, DIDDoc, DID Log, and some of the intermediate data structures. This example includes witnesses and an example <code>did-witnesses.json</code> file.</p> <p>The examples are aligned with Version 0.5 of the <code>did:webvh</code> specification.</p> <p>In some of the following examples the data for the DID log entries is displayed as prettified JSON for readability. In the log itself, the JSON has all whitespace removed, and each line ends with a <code>CR</code>, per the JSON Lines convention.</p>"},{"location":"example/#did-creation-data","title":"DID Creation Data","text":"<p>These examples show the important structures used in the Create (Register) operation for a <code>did:webvh</code> DID. The examples were generated from the <code>did:webvh</code> Python implementation. See this folder in the Python implementation repository for the latest examples.</p>"},{"location":"example/#input-to-the-scid-generation-process-with-placeholders","title":"Input to the SCID Generation Process with Placeholders","text":"<p>The following JSON is an example of the input that the DID Controller constructs and passes into the SCID Generation Process. In this example, the DIDDoc is particularly boring, containing the absolute minimum for a valid DIDDoc.</p> <p>This example includes the initial \"authorized keys\" to sign the Data Integrity proof (<code>updateKeys</code>), the pre-rotation commitment to the next authorization keys (<code>nextKeyHashes</code>), and the DIDs that must witness the updates. All are in the <code>parameters</code> property in the log entry.</p> <pre><code>{\n  \"versionId\": \"{SCID}\",\n  \"versionTime\": \"2025-04-01T17:39:50Z\",\n  \"parameters\": {\n    \"witness\": {\n      \"threshold\": 2,\n      \"witnesses\": [\n        {\n          \"id\": \"did:key:z6Mkkc51mg2vpQzKWAbWQZupeGYhowaBjYkmvcKMTqteqHB4\",\n          \"weight\": 1\n        },\n        {\n          \"id\": \"did:key:z6MkuDdJdKLCgwZuQuEi9xG6LVgJJ9Tebr74CXPYPSumqgJs\",\n          \"weight\": 1\n        },\n        {\n          \"id\": \"did:key:z6MkoSWmQyp4fTk4ZQy4KUsss9dFX51XfEUzKKKj1J1JUsrF\",\n          \"weight\": 1\n        }\n      ]\n    },\n    \"updateKeys\": [\n      \"z6MkgzBDcBFV3sk4ypPE5YXMZHmS213A3HpYY2LmcVKV15jr\"\n    ],\n    \"nextKeyHashes\": [\n      \"QmZreDcjvWEpyRFznQeExWNCsvMLk5i59AcRJJuQC8UodJ\"\n    ],\n    \"method\": \"did:webvh:0.5\",\n    \"scid\": \"{SCID}\"\n  },\n  \"state\": {\n    \"@context\": [\n      \"https://www.w3.org/ns/did/v1\"\n    ],\n    \"id\": \"did:webvh:{SCID}:domain.example\"\n  }\n}\n</code></pre>"},{"location":"example/#output-of-the-scid-generation-process","title":"Output of the SCID Generation Process","text":"<p>After the SCID is generated, the literal <code>{SCID}</code> placeholders are replaced by the generated SCID value (see below). This JSON is the input to the <code>entryHash</code> generation process -- with the SCID used as the value of the  <code>versionId</code>. Once the process has run, the version number of this first DID log entry (<code>1</code>), a dash <code>-</code> and the resulting output hash will replace the SCID as the <code>versionId</code> value in the published DID Log Entry.</p> <pre><code>{\n  \"versionId\": \"QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE\",\n  \"versionTime\": \"2025-04-01T17:39:50Z\",\n  \"parameters\": {\n    \"witness\": {\n      \"threshold\": 2,\n      \"witnesses\": [\n        {\n          \"id\": \"did:key:z6Mkkc51mg2vpQzKWAbWQZupeGYhowaBjYkmvcKMTqteqHB4\",\n          \"weight\": 1\n        },\n        {\n          \"id\": \"did:key:z6MkuDdJdKLCgwZuQuEi9xG6LVgJJ9Tebr74CXPYPSumqgJs\",\n          \"weight\": 1\n        },\n        {\n          \"id\": \"did:key:z6MkoSWmQyp4fTk4ZQy4KUsss9dFX51XfEUzKKKj1J1JUsrF\",\n          \"weight\": 1\n        }\n      ]\n    },\n    \"updateKeys\": [\n      \"z6MkgzBDcBFV3sk4ypPE5YXMZHmS213A3HpYY2LmcVKV15jr\"\n    ],\n    \"nextKeyHashes\": [\n      \"QmZreDcjvWEpyRFznQeExWNCsvMLk5i59AcRJJuQC8UodJ\"\n    ],\n    \"method\": \"did:webvh:0.5\",\n    \"scid\": \"QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE\"\n  },\n  \"state\": {\n    \"@context\": [\n      \"https://www.w3.org/ns/did/v1\"\n    ],\n    \"id\": \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example\"\n  }\n}\n</code></pre>"},{"location":"example/#data-integrity-proof-generation-and-first-log-entry","title":"Data Integrity Proof Generation and First Log Entry","text":"<p>The last step in the creation of the first log entry is the generation of the data integrity proof. One of the keys in the <code>updateKeys</code> [[ref: parameter MUST be the <code>verificationMethod</code> in the proof (in <code>did:key</code> form) to generate the signature across the post-entryHash processed DID log entry. The generated proof is added to the JSON Line and the log entry JSON object becomes the first entry in the [[ref: DID Log.</p> <p>The following is the JSON prettified entry log file that is published as the initial <code>did.jsonl</code> file. When published, all extraneous whitespace is removed, as shown in the block below the pretty-printed instance.</p> <pre><code>{\n  \"versionId\": \"1-QmQ6FJ4fk2xheSSQoEjVpTgx9AQPKhJgtR9hn1nr4EeCrZ\",\n  \"versionTime\": \"2025-04-01T17:39:50Z\",\n  \"parameters\": {\n    \"witness\": {\n      \"threshold\": 2,\n      \"witnesses\": [\n        {\n          \"id\": \"did:key:z6Mkkc51mg2vpQzKWAbWQZupeGYhowaBjYkmvcKMTqteqHB4\",\n          \"weight\": 1\n        },\n        {\n          \"id\": \"did:key:z6MkuDdJdKLCgwZuQuEi9xG6LVgJJ9Tebr74CXPYPSumqgJs\",\n          \"weight\": 1\n        },\n        {\n          \"id\": \"did:key:z6MkoSWmQyp4fTk4ZQy4KUsss9dFX51XfEUzKKKj1J1JUsrF\",\n          \"weight\": 1\n        }\n      ]\n    },\n    \"updateKeys\": [\n      \"z6MkgzBDcBFV3sk4ypPE5YXMZHmS213A3HpYY2LmcVKV15jr\"\n    ],\n    \"nextKeyHashes\": [\n      \"QmZreDcjvWEpyRFznQeExWNCsvMLk5i59AcRJJuQC8UodJ\"\n    ],\n    \"method\": \"did:webvh:0.5\",\n    \"scid\": \"QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE\"\n  },\n  \"state\": {\n    \"@context\": [\n      \"https://www.w3.org/ns/did/v1\"\n    ],\n    \"id\": \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example\"\n  }\n}\n</code></pre> <p>The same content \"un-prettified\", as it is found in the <code>did.jsonl</code> file, with the <code>proof</code> attached:</p> <pre><code>{\"versionId\": \"1-QmQ6FJ4fk2xheSSQoEjVpTgx9AQPKhJgtR9hn1nr4EeCrZ\", \"versionTime\": \"2025-04-01T17:39:50Z\", \"parameters\": {\"witness\": {\"threshold\": 2, \"witnesses\": [{\"id\": \"did:key:z6Mkkc51mg2vpQzKWAbWQZupeGYhowaBjYkmvcKMTqteqHB4\", \"weight\": 1}, {\"id\": \"did:key:z6MkuDdJdKLCgwZuQuEi9xG6LVgJJ9Tebr74CXPYPSumqgJs\", \"weight\": 1}, {\"id\": \"did:key:z6MkoSWmQyp4fTk4ZQy4KUsss9dFX51XfEUzKKKj1J1JUsrF\", \"weight\": 1}]}, \"updateKeys\": [\"z6MkgzBDcBFV3sk4ypPE5YXMZHmS213A3HpYY2LmcVKV15jr\"], \"nextKeyHashes\": [\"QmZreDcjvWEpyRFznQeExWNCsvMLk5i59AcRJJuQC8UodJ\"], \"method\": \"did:webvh:0.5\", \"scid\": \"QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE\"}, \"state\": {\"@context\": [\"https://www.w3.org/ns/did/v1\"], \"id\": \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example\"}, \"proof\": [{\"type\": \"DataIntegrityProof\", \"cryptosuite\": \"eddsa-jcs-2022\", \"verificationMethod\": \"did:key:z6MkgzBDcBFV3sk4ypPE5YXMZHmS213A3HpYY2LmcVKV15jr#z6MkgzBDcBFV3sk4ypPE5YXMZHmS213A3HpYY2LmcVKV15jr\", \"created\": \"2025-04-01T17:39:50Z\", \"proofPurpose\": \"authentication\", \"proofValue\": \"zQZVJizP7UGAoLzGYGvHmTUhQVs7fFByj4zNP9N1vGHARtWfyupxEp1qjLQ65iKuvHrtXhUe6UXfCNJA6WYLwvg5\"}]}\n</code></pre>"},{"location":"example/#didweb-instance-of-diddoc","title":"<code>did:web</code> Instance of DIDDoc","text":"<p>As noted in the publishing a parallel <code>did:web</code> DID section of this specification a <code>did:webvh</code> can be published by replacing <code>did:webvh</code> with <code>did:web</code> in the DIDDoc, adding an <code>alsoKnownAs</code> entry for the <code>did:webvh</code> and publishing the resulting DIDDoc at <code>did.json</code>, logically beside the <code>did.jsonl</code> file.</p> <p>Here is what the <code>did:web</code> DIDDoc looks like for the <code>did:webvh</code> above.</p> <pre><code>{\n    \"@context\": [\n      \"https://www.w3.org/ns/did/v1\"\n    ],\n    \"id\": \"did:web:domain.example\",\n    \"alsoKnownAs\": [\"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example\"]\n}\n</code></pre>"},{"location":"example/#did-log-entry-2-of-the-diddoc","title":"DID Log Entry 2 of the DIDDoc","text":"<p>Time passes, and the DID Controller of the <code>did:webvh</code> DID decides to update its DID to a new version, <code>2</code>. In this case, the DIDDoc is substantially updated, with a <code>verificationMethod</code> and service added to the DIDDoc. As well, per the <code>did:webvh</code> specification when [pre-rotation] is being used, the <code>updateKeys</code> and <code>nextKeyHashes</code> in the <code>parameters</code> are updated. The rest of the <code>parameters</code> are unchanged, and so not included.</p>"},{"location":"example/#version-2-entry-hashing-input","title":"Version 2 Entry Hashing Input","text":"<p>To generate a new DID log entry, the DID Controller needs to provide the updated <code>parameters</code>, and the new DIDDoc. The following processing is done to create the new DID log entry:</p> <ul> <li>The <code>versionId</code> from the previous (first) log entry is made the value   of the <code>versionId</code> in the new log entry.</li> <li>The <code>versionTime</code> in the new log entry is set to the current time.</li> <li>The <code>parameters</code> entry passed in is processed. In this case, since the <code>updateKeys</code> array is updated, and pre-rotation is active, the a verification is done to ensure that the hash of the <code>updateKeys</code> entries are found in the <code>nextKeyHashes</code> property from DID log entry 1 of the DID. As required by the <code>did:webvh</code> specification, a new <code>nextKeyHashes</code> is included in the new <code>parameters</code>.</li> <li>The new (but unchanged) DIDDoc is included in its entirety, as the value of the <code>state</code> property.</li> <li>The resultant JSON object is passed into the <code>entryHash</code> generation   process which outputs the   <code>entryHash</code> for this log entry. Once again, the <code>versionId</code> value is   replaced by the version number (the previous version number plus <code>1</code>, so <code>2</code>   in this case), a dash (<code>-</code>), and the new <code>entryHash</code>.</li> <li>The data integrity proof is generated added to the log   entry, spaces are removed, a <code>CR</code> character added (per JSON Lines)   and the entire entry is appended to the existing DID log file.</li> </ul> <p>The DID log file can now be published, optionally with an update to the corresponding <code>did:web</code> DID.</p> <p>The following is the JSON pretty-print log entry for the second DID log entry of our example <code>did:webvh</code>. Things to note in this example:</p> <ul> <li>Because pre-rotation of the authorized keys (<code>updateKeys</code>) is in effect (based on the presence of the <code>nextKeyHashes</code> item), the Data Integrity proof is signed by a key in the <code>updateKeys</code> item from this DID log entry.</li> <li>When pre-rotation is not active, the <code>updateKeys</code> active based on the previous DID log entry would have been used. This is covered in the Authorized Keys section of the <code>did:webvh</code> specification.</li> <li>A new <code>updateKeys</code> property in the <code>parameters</code> has been defined, along with   commitment to a future key (<code>nextKeyHashes</code>) that will control a subsequent update   to the DID. Since pre-rotation was already active, the multihash of the keys in the <code>updateKeys</code> item in this DID log entry must be in the <code>nextKeyHashes</code> item of the previous DID log entry.</li> </ul> <pre><code>{\n  \"versionId\": \"2-QmbCoFcFACuFQNqsSAcHvnPTNnJpkWdiZ9dcf2nwxSWq6j\",\n  \"versionTime\": \"2025-04-01T17:39:51Z\",\n  \"parameters\": {\n    \"updateKeys\": [\n      \"z6MkrZC56Sc72278z3mpyBWrFPuZ5P1EnMPx1uKTmK6VhGTh\"\n    ],\n    \"nextKeyHashes\": [\n      \"QmScCC6BgnbNNy8ADyxkJ2xamnC6iPpDDtPH79YtohNcBh\"\n    ]\n  },\n  \"state\": {\n    \"@context\": [\n      \"https://www.w3.org/ns/did/v1\",\n      \"https://w3id.org/security/multikey/v1\",\n      \"https://identity.foundation/.well-known/did-configuration/v1\"\n    ],\n    \"id\": \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example\",\n    \"authentication\": [\n      \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example#z6MkjU89vLCBmQUW9rdbUCNrSqeNfCTHV5L45kBZN8Ljj1mT\"\n    ],\n    \"assertionMethod\": [\n      \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example#z6MkjU89vLCBmQUW9rdbUCNrSqeNfCTHV5L45kBZN8Ljj1mT\"\n    ],\n    \"verificationMethod\": [\n      {\n        \"id\": \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example#z6MkjU89vLCBmQUW9rdbUCNrSqeNfCTHV5L45kBZN8Ljj1mT\",\n        \"controller\": \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example\",\n        \"type\": \"Multikey\",\n        \"publicKeyMultibase\": \"z6MkjU89vLCBmQUW9rdbUCNrSqeNfCTHV5L45kBZN8Ljj1mT\"\n      }\n    ],\n    \"service\": [\n      {\n        \"id\": \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example#domain\",\n        \"type\": \"LinkedDomains\",\n        \"serviceEndpoint\": \"https://domain.example\"\n      }\n    ]\n  },\n  \"proof\": [\n    {\n      \"type\": \"DataIntegrityProof\",\n      \"cryptosuite\": \"eddsa-jcs-2022\",\n      \"verificationMethod\": \"did:key:z6MkrZC56Sc72278z3mpyBWrFPuZ5P1EnMPx1uKTmK6VhGTh#z6MkrZC56Sc72278z3mpyBWrFPuZ5P1EnMPx1uKTmK6VhGTh\",\n      \"created\": \"2025-04-01T17:39:51Z\",\n      \"proofPurpose\": \"authentication\",\n      \"proofValue\": \"z2uiQcW8mDt7DphWmT7o9FCgZyvC7wJQSN9zUMPEson8bGboAg9jAek8RihzxAhA4bMja8zN7Z9BTe1WjJja99yk5\"\n    }\n  ]\n}\n</code></pre>"},{"location":"example/#did-log-file-for-version-2","title":"DID Log File For Version 2","text":"<p>The new version 2 <code>did.jsonl</code> file contains two DID log entries, one for each version of the DIDDoc -- as per the use of JSON Lines.</p> <pre><code>{\"versionId\": \"1-QmQ6FJ4fk2xheSSQoEjVpTgx9AQPKhJgtR9hn1nr4EeCrZ\", \"versionTime\": \"2025-04-01T17:39:50Z\", \"parameters\": {\"witness\": {\"threshold\": 2, \"witnesses\": [{\"id\": \"did:key:z6Mkkc51mg2vpQzKWAbWQZupeGYhowaBjYkmvcKMTqteqHB4\", \"weight\": 1}, {\"id\": \"did:key:z6MkuDdJdKLCgwZuQuEi9xG6LVgJJ9Tebr74CXPYPSumqgJs\", \"weight\": 1}, {\"id\": \"did:key:z6MkoSWmQyp4fTk4ZQy4KUsss9dFX51XfEUzKKKj1J1JUsrF\", \"weight\": 1}]}, \"updateKeys\": [\"z6MkgzBDcBFV3sk4ypPE5YXMZHmS213A3HpYY2LmcVKV15jr\"], \"nextKeyHashes\": [\"QmZreDcjvWEpyRFznQeExWNCsvMLk5i59AcRJJuQC8UodJ\"], \"method\": \"did:webvh:0.5\", \"scid\": \"QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE\"}, \"state\": {\"@context\": [\"https://www.w3.org/ns/did/v1\"], \"id\": \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example\"}, \"proof\": [{\"type\": \"DataIntegrityProof\", \"cryptosuite\": \"eddsa-jcs-2022\", \"verificationMethod\": \"did:key:z6MkgzBDcBFV3sk4ypPE5YXMZHmS213A3HpYY2LmcVKV15jr#z6MkgzBDcBFV3sk4ypPE5YXMZHmS213A3HpYY2LmcVKV15jr\", \"created\": \"2025-04-01T17:39:50Z\", \"proofPurpose\": \"authentication\", \"proofValue\": \"zQZVJizP7UGAoLzGYGvHmTUhQVs7fFByj4zNP9N1vGHARtWfyupxEp1qjLQ65iKuvHrtXhUe6UXfCNJA6WYLwvg5\"}]}\n{\"versionId\": \"2-QmbCoFcFACuFQNqsSAcHvnPTNnJpkWdiZ9dcf2nwxSWq6j\", \"versionTime\": \"2025-04-01T17:39:51Z\", \"parameters\": {\"updateKeys\": [\"z6MkrZC56Sc72278z3mpyBWrFPuZ5P1EnMPx1uKTmK6VhGTh\"], \"nextKeyHashes\": [\"QmScCC6BgnbNNy8ADyxkJ2xamnC6iPpDDtPH79YtohNcBh\"]}, \"state\": {\"@context\": [\"https://www.w3.org/ns/did/v1\", \"https://w3id.org/security/multikey/v1\", \"https://identity.foundation/.well-known/did-configuration/v1\"], \"id\": \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example\", \"authentication\": [\"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example#z6MkjU89vLCBmQUW9rdbUCNrSqeNfCTHV5L45kBZN8Ljj1mT\"], \"assertionMethod\": [\"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example#z6MkjU89vLCBmQUW9rdbUCNrSqeNfCTHV5L45kBZN8Ljj1mT\"], \"verificationMethod\": [{\"id\": \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example#z6MkjU89vLCBmQUW9rdbUCNrSqeNfCTHV5L45kBZN8Ljj1mT\", \"controller\": \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example\", \"type\": \"Multikey\", \"publicKeyMultibase\": \"z6MkjU89vLCBmQUW9rdbUCNrSqeNfCTHV5L45kBZN8Ljj1mT\"}], \"service\": [{\"id\": \"did:webvh:QmdmPkUdYzbr9txmx8gM2rsHPgr5L6m3gHjJGAf4vUFoGE:domain.example#domain\", \"type\": \"LinkedDomains\", \"serviceEndpoint\": \"https://domain.example\"}]}, \"proof\": [{\"type\": \"DataIntegrityProof\", \"cryptosuite\": \"eddsa-jcs-2022\", \"verificationMethod\": \"did:key:z6MkrZC56Sc72278z3mpyBWrFPuZ5P1EnMPx1uKTmK6VhGTh#z6MkrZC56Sc72278z3mpyBWrFPuZ5P1EnMPx1uKTmK6VhGTh\", \"created\": \"2025-04-01T17:39:51Z\", \"proofPurpose\": \"authentication\", \"proofValue\": \"z2uiQcW8mDt7DphWmT7o9FCgZyvC7wJQSN9zUMPEson8bGboAg9jAek8RihzxAhA4bMja8zN7Z9BTe1WjJja99yk5\"}]}\n</code></pre>"},{"location":"example/#witnessjson-file-after-version-2","title":"<code>witness.json</code> File After Version 2","text":"<p>Since this DID has been configured to have witnesses (3, with a required threshold of 2, as noted in DID Log Entry 1), there is a <code>witness.json</code> file associated with the DID. The witness proofs are Data Integrity proofs, signed by the <code>did:key</code> DIDs of the witnesses, with a payload of the <code>versionId</code> value for the most recently witnessed DID log entry. The <code>witness.json</code> file is as follows:</p> <p>[   {     \"versionId\": \"2-QmbCoFcFACuFQNqsSAcHvnPTNnJpkWdiZ9dcf2nwxSWq6j\",     \"proof\": [       {         \"type\": \"DataIntegrityProof\",         \"cryptosuite\": \"eddsa-jcs-2022\",         \"verificationMethod\": \"didz6Mkkc51mg2vpQzKWAbWQZupeGYhowaBjYkmvcKMTqteqHB4#z6Mkkc51mg2vpQzKWAbWQZupeGYhowaBjYkmvcKMTqteqHB4\",         \"created\": \"2025-04-01T17:39:51Z\",         \"proofPurpose\": \"assertionMethod\",         \"proofValue\": \"zAJbjewF2RpV4DMCCyYaui6jmcSEJgEMUj7rAZ9543hcurTN6ahfTWBwTFdSbh46HdP59E3V89GpaC45Df9W2uB3\"       },       {         \"type\": \"DataIntegrityProof\",         \"cryptosuite\": \"eddsa-jcs-2022\",         \"verificationMethod\": \"didz6MkuDdJdKLCgwZuQuEi9xG6LVgJJ9Tebr74CXPYPSumqgJs#z6MkuDdJdKLCgwZuQuEi9xG6LVgJJ9Tebr74CXPYPSumqgJs\",         \"created\": \"2025-04-01T17:39:51Z\",         \"proofPurpose\": \"assertionMethod\",         \"proofValue\": \"z5BR5iViZoj2AkFakKCpiSrD9fstM3Ba88C9vBiyiqyzeCyZueoipfEuKikXgkRGtEcwvMkTaQFijjrB2tEmVJb81\"       }     ]   } ]</p> <p>Note that there are only two signatures (because the threshold is 2), and the proofs both reference the <code>versionId</code> of the second DID log entry of the DID. What about the first DID log entry?  As per the specification (here), the signing of a later DID log entry implies that the signing witness is approving of (\"witnessing\") all prior DID log entries. So since the witnesses are the same for DID log entries 1 and 2, the witness proofs on DID log entry 2 are sufficient for DID log entry 1 as well.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#why-json-lines","title":"Why JSON Lines?","text":"<p>JSON Lines (newline-delimited JSON) is a format where each line is a valid JSON object. It\u2019s widely used in data streaming, logging, and large-scale data processing.</p>"},{"location":"faq/#benefits-of-json-lines","title":"Benefits of JSON Lines","text":"<p>1. Streaming-Friendly JSON Lines allows data to be processed one entry at a time. This means applications can handle very large datasets without loading everything into memory.</p> <p>2. Incremental Parsing Each line is self-contained. Parsers can begin consuming data as soon as the first line is received, which enables early processing and partial reads.</p> <p>3. Easy Appending New records can be added to the end of a file without modifying or re-serializing the existing content\u2014ideal for systems that grow over time.</p> <p>4. Simple Tooling Line-based formats work well with traditional Unix tools (<code>grep</code>, <code>awk</code>, <code>sed</code>) and can be parsed with minimal code in most languages.</p>"},{"location":"faq/#performance-trade-offs","title":"Performance Trade-offs","text":"<p>Benchmarks show that single JSON arrays may parse slightly faster in some environments. However, the practical benefits of JSON Lines\u2014especially for scalability, simplicity, and streaming use cases\u2014often outweigh the marginal performance difference.</p> <p>JSON Lines is a strong choice for systems dealing with large, growing, or streamed data where simplicity and flexibility matter.</p>"},{"location":"implementations/","title":"did:webvh Registrars/Resolvers","text":"<p>Implementations of <code>did:webvh</code> software for DID Controller registrars and resolvers can be found here:</p> <ul> <li>Typescript</li> <li>Python</li> <li>Go</li> <li><code>did:webvh</code> Server - Python</li> </ul> <p>The implementations support most of the features of the core <code>did:webvh</code> (including key pre-rotation and witnesses) to the v0.4 version of the specification.</p>"},{"location":"overview/","title":"Overview","text":"<p>The emergence of Decentralized Identifiers (DIDs) and with them the evolution of DID Methods continues to be a dynamic area of development in the quest for trusted, secure and private digital identity management where the users are in control of their own data.</p> <p>The <code>did:web</code> method provides a solution that is recognized  for its simplicity of deployment and its cost-effectiveness, allowing for easy establishment of a  credential ecosystem. It leverages the Domain Name System (DNS) to perform the DID operations including  DID-to-HTTPS transformation and allowing for DIDs to be associated with a domain's reputation or published  on platforms such as GitHub. This approach is, however, not without its challenges. It is, for example, not  inherently decentralized as it relies on DNS domain names, which require centralized registries. In addition  <code>did:web</code> lacks a cryptographically verifiable, tamper-resistant, and persistently stored DID document, including its verifiable history.</p> <p>We propose the <code>did:webhv</code> (<code>did:web</code> + Verifiable History) method presented here as an enhancement of <code>did:web</code>, providing a solution to address the limitations inherent of <code>did:web</code>. The <code>did:webvh</code> was called <code>did:tdw</code> through version v0.4 of the specification. <code>did:webvh</code> introduces features such as a verifiable history, akin to what is available with ledger-based DIDs, but without relying on a ledger, a self-certifying identifiers (SCIDs), and authorized key(s) to increase control over the creation, update, and deactivation of a DID. Furthermore, the <code>did:webvh</code> method provides a more decentralized approach by ensuring that the security of the embedded SCID does not depend on DNS, and enables resolving a cryptographically verifiable trust registry and status lists, using DID-Linked Resources, which <code>did:web</code> lacks. </p> <p>In summary, the <code>did:webvh</code> method offers a higher level of assurance for those requiring more robust verification processes compared to what is provided by <code>did:web</code>. It also represents a significant stride towards a more trusted and secure web, where the integrity of cryptographic key publishing and management is paramount. In addition, <code>did:webvh</code> maintains backward compatibility with <code>did:web</code> and the resulting DID can be published as both <code>did:web</code> and <code>did:webvh</code>. These possibilities carter to a flexible and broader range of use cases and corresponding trust requirements, addressing both those who are comfortable with the existing <code>did:web</code> infrastructure to those seeking greater security assurances provided by <code>did:webvh</code>. </p>"},{"location":"overview/#a-tldr-summary-of-didwebvh","title":"A <code>tl;dr</code> summary of <code>did:webvh</code>","text":""},{"location":"overview/#the-didwebvh-structure-or-where-is-the-did-doc","title":"The <code>did:webvh</code> Structure (or, Where is the <code>DID Doc</code>??)","text":"<ul> <li><code>did:webvh</code> uses a so-called DID Log to publish cryptographic material and capabilities</li> <li>A <code>DID Log</code> is stored as <code>did.jsonl</code> file and represents a list of entries, each formatted as JSON line</li> <li> <p>Every <code>DID Log Entry</code> describes a specific version of the corresponding DID via a JSON object</p> <ul> <li>DID Log Entry := <code>{ \"versionId\": \"\", \"versionTime\": \"\", \"parameters\": {}, \"state\": {}, \"proof\" : [] }</code> <ul> <li><code>versionId</code> -- a value that combines the version number (starting at <code>1</code> and incremented by one per version), followed by a literal dash <code>-</code>, and a hash of the entry, which links each entry to its predecessor in a ledger-like chain</li> <li><code>versionTime</code> -- a string in UTC ISO8601 format </li> <li><code>parameters</code> -- a set of parameters that impact the processing of the current and future log entries<ul> <li>method</li> <li>SCID</li> <li>updateKeys</li> <li>portable (optional)</li> <li>prerotation (optional)</li> <li>nextKeyHashes (optional)</li> <li>witnesses (optional)</li> <li>deactivated (when accurate)</li> <li>ttl (optional)</li> </ul> </li> </ul> </li> <li><code>state</code> -- the current version of the DIDDoc</li> <li><code>proof</code>-- a Data Integrity (DI) proof calculated across the entry, signed by a DID Controller authorized key to update the DIDDoc, and optionally, a set of witnesses that monitor the actions of the DID Controller</li> </ul> </li> <li> <p>The entire <code>DID Doc</code> is part of the \"state\" object (in every JSON line of a DID Log Entry within the DID Log File)</p> </li> </ul>"},{"location":"overview/#creating-the-first-did-doc","title":"Creating the first DID Doc","text":"<ol> <li> <p>Create a preliminary log entry</p> <ul> <li>Create the JSON structure with the aforementioned properties and the following values:<ul> <li><code>versionId</code> := the literal string \"<code>{SCID}</code>\"</li> <li><code>versionTime</code> := as asserted by the DID Controller, for example, <code>\"2024-04-05T07:32:58Z\"</code></li> <li><code>parameters</code> := as needed and defined by the DID Controller, for example:<ul> <li>method := <code>did:webvh:0.4</code></li> <li>SCID := the literal string \"<code>{SCID}</code>\" (here and wherever the calculated SCID value will eventually be placed)</li> </ul> </li> <li><code>state</code> := initial DID Doc with placeholders (the literal string \"<code>{SCID}</code>\") wherever the calculated SCID value will eventually be placed</li> <li><code>proof</code> := not set at this point. Will be set in step 4 below</li> </ul> </li> </ul> </li> <li> <p>Calculate the SCID</p> <ul> <li>SCID := <code>base58btc(multihash(JCS(preliminary log entry with placeholders), &lt;hash algorithm&gt;))</code><ul> <li><code>JCS</code> := an implementation of the JSON Canonicalization Scheme (RFC8785)</li> <li><code>multihash</code> := an implementation of the multihash specification</li> <li><code>&lt;hash algorithm&gt;</code> := one of the hash algorithms accepted by  <code>did:webvh</code> (see parameters in the specification)</li> <li><code>base58btc</code> := an implementation of the base58btc function</li> </ul> </li> </ul> </li> <li> <p>Update the preliminary log entry</p> <ul> <li>Replace all placeholders (the literal string <code>{SCID}</code>) with the calculated SCID value.</li> <li>Calculate the <code>entryHash</code> as <code>entryHash := base58btc(multihash(JCS(entry), &lt;hash algorithm&gt;))</code>.</li> <li>Set the <code>versionId</code> to <code>1</code> (for version 1 of the DID), followed by a literal dash <code>-</code>, followed by the calculated <code>entryHash</code>.</li> </ul> </li> <li> <p>Calculate the data integrity (DI) proof</p> <ul> <li><code>proof</code> := a proof calculated across the entire DID Log Entry and signed with an <code>updateKeys</code> (and optionally by witnesses). Values of required attributes include:<ul> <li><code>type</code> := <code>DataIntegrityProof</code></li> <li><code>cryptosuite</code> := <code>eddsa-jcs-2022</code></li> <li><code>proofPurpose</code> := <code>assertionMethod</code></li> </ul> </li> </ul> </li> <li> <p>Add the DI proof to the <code>proof</code> property of the DID Log Entry</p> </li> </ol>"},{"location":"overview/#creating-the-first-did-log","title":"Creating the first DID Log","text":"<ul> <li>Turn the Log Entry into a JSON Line according the JSON Lines specification and add the line to the DID Log File for publication</li> </ul>"},{"location":"overview/#some-considerations","title":"Some considerations","text":"<ul> <li>When updating the DID to a new version:<ul> <li>The SCID is only calculated when creating the first DID Log Entry, and   only used as the <code>versionId</code> when calculating the <code>entryHash</code> of that   first entry.</li> <li>For each a new log entry after the first, the <code>entryHash</code> is calculated   with its <code>versionId</code> set to the <code>versionId</code> of the prior log entry. This   results in all of the entries being cryptographically \"chained\" together   such that an alteration to an entry is evident in all succeeding entries.</li> <li>The <code>versionId</code> is the number of the version (incrementing by one per version), the literal <code>-</code>, followed by the calculated <code>entryHash</code> for the entry.</li> <li>Note: Both the SCID and the <code>entryHash</code> are calculated before the DI   proof calculation is added to the entry.</li> </ul> </li> <li><code>did:webvh</code> uses the same DID-to-HTTPS transformation as <code>did:web</code>, so   <code>did:webvh</code>'s  <code>did.jsonl</code> (JSON Lines) file is found in the same location as   <code>did:web</code>'s <code>did.json</code> file, and supports an easy transition from <code>did:web</code> to   gain the added benefits of <code>did:webvh</code>.</li> <li>For backwards compatibility, and for verifiers that \"trust\" <code>did:web</code>, a <code>did:webvh</code> can be trivially modified and published in parallel to a <code>did:web</code> DID. For resolvers that want more assurance, <code>did:webvh</code> provides a way to \"trust did:web\" (or to enable a \"trusted web\" if you say it fast) enabled by the features listed in the introduction.</li> </ul>"},{"location":"root_CODE_OF_CONDUCT/","title":"Code of Conduct","text":"<p>We are committed to providing a friendly, safe and welcoming environment for all, regardless of the level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristics.</p> <p>Examples of behavior that contributes to creating a positive environment include: - Being kind and courteous to others - Using welcoming and inclusive language - Being respectful of differing viewpoints and experiences - Collaborating with other community members - Gracefully accepting constructive criticism - Focusing on what is best for the community - Showing empathy towards other community members</p> <p>Examples of unacceptable behavior by participants include: - The use of sexualized language or imagery and sexual attention or advances - The use of inappropriate images, including in a community member's avatar - The use of inappropriate language, including in a community member's nickname - Any spamming, flaming, baiting, or other attention-stealing behavior - Trolling, insulting/derogatory comments, and personal or political attacks - Public or private harassment - Publishing others' private information, such as a physical or electronic address, without explicit permission - Discussing topics that are overly polarizing, sensitive, or incite arguments. This includes the discussion of polarizing political views, violence, suicide, and rape. - Responding with \u201cRTFM\u201d, \"just google it\u201d or similar phrases in response to help requests - Other conduct which could reasonably be considered inappropriate</p>"},{"location":"root_CODE_OF_CONDUCT/#our-goals","title":"Our Goals","text":"<p>The goal of this document is to set the overall tone for our community. This isn\u2019t an exhaustive list of things you can and can't do. Rather, take this document in the spirit in which it\u2019s intended, and try to be your best self. We value many things beyond technical expertise, including collaboration and supporting others within our community. Providing a positive experience for other community members can have a much more significant impact than simply providing the correct answer.</p>"},{"location":"root_CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies to all spaces within the Trust DID Web community. This includes, but is not limited to, the Discord server, our repositories on GitHub, and meet-ups. In addition, violations of this code outside these spaces may affect a person's ability to participate within them.</p> <p>The Code of Conduct applies equally to all members of the community, including staff.</p>"},{"location":"root_CODE_OF_CONDUCT/#code-of-conduct-policies","title":"Code of Conduct Policies","text":""},{"location":"root_CODE_OF_CONDUCT/#moderation-policies","title":"Moderation Policies","text":"<p>These are the policies for upholding our community\u2019s rules and the code of conduct. If you want to report a situation that needs to be reviewed by our team, please see our reporting guide below.</p>"},{"location":"root_CODE_OF_CONDUCT/#reporting-guide","title":"Reporting Guide","text":"<p>Instances of behaviors that violate the Code of Conduct or rules may be reported by any member of the community. Community members are encouraged to report these situations, including situations they witness involving other community members. You may report in the following ways: * By tagging @swcurran on the Discord server in situations that require immediate attention. * By sending a direct message (DM) to the Decentralized Identity Foundation Executive Director kimdhamilton.</p>"},{"location":"root_CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct and parts of the policies are adapted from the Adafruit Community Code of Conduct and Django Code of Conduct</p>"},{"location":"root_CONTRIBUTOR/","title":"DIF Contributor Agreement","text":"<p>By contributing to any discussion, code, issues, pull requests, or other forms of contribution to this repository and in all other DIF mediums where discussion, development, and collaboration on its contents are taking place, your contributions are bound by DIF's standard license and attribution selections, as detailed below:</p>"},{"location":"root_CONTRIBUTOR/#copyright-policy","title":"Copyright Policy","text":"<p>The copyright mode for all materials and content associated with this repository and development initiative are licensed under Creative Commons Attribution 4.0.</p>"},{"location":"root_CONTRIBUTOR/#source-code","title":"Source Code","text":"<p>Source code contributions are subject to the Developer Certificate of Origin version 1.1, available at http://developercertificate.org/, and all code is subject to the Apache 2.0 license, available at http://www.apache.org/licenses/LICENSE-2.0.html.</p>"},{"location":"root_CONTRIBUTOR/#patent-licensing","title":"Patent Licensing","text":"<p>The patent mode for all code, materials, and content in this repo, and associated with  development of this initiative, are licensed under the W3C's Patent Policy, as detailed below:</p> <ol> <li> <p>Licensing Commitment.  Each contributor agrees to make available any of its Essential Claims, as defined in the W3C Patent Policy (available at http://www.w3.org/Consortium/Patent-Policy-20040205), under the W3C RF licensing requirements Section 5 (http://www.w3.org/Consortium/Patent-Policy-20040205), as if the contribution was contained in or associated with a W3C Recommendation.</p> </li> <li> <p>For Exclusion.  Prior to committing any code, bug reports, pull requests, or other forms of contribution, a contributor may exclude Essential Claims from its licensing commitments under this agreement by providing written notice of that intent to DIF's Executive Director (and must received confirmation of receipt for the exclusion to have effect).  The Exclusion Notice for issued patents and published applications must include the patent number(s) or title and application number(s), as the case may be, for each of the issued patent(s) or pending patent application(s) that the contributor wishes to exclude from the licensing commitment set forth in Section 1 of this patent policy.  If an issued patent or pending patent application that may contain Essential Claims is not set forth in the Exclusion Notice, those Essential Claims shall continue to be subject to the licensing commitments under this agreement.  The Exclusion Notice for unpublished patent applications must provide either: (i) the text of the filed application; or (ii) identification of the specific part(s) of the contribution whose implementation makes the excluded claim an Essential Claim.  If (ii) is chosen, the effect of the exclusion will be limited to the identified part(s) of the contribution.  DIF's Executive Director will publish Exclusion Notices.</p> </li> </ol>"},{"location":"root_README/","title":"did:webvh DID Method - Information","text":"<p>This is the information site/repository for the did:webvh (\"<code>did:web</code> + Verifiable History\") DID Method. This DID Method was formerly called <code>did:tdw</code> (\"Trust DID Web\").</p> <p><code>did:webvh</code> information is published at https://didwebvh.info</p> <p>The <code>did:webvh</code> specification is published at https://identity.foundation/didwebvh</p>"},{"location":"root_README/#contributing","title":"Contributing","text":"<p>Contributions to this information site are welcome! Feel free to improve the content found here about the DID Method:</p> <ul> <li>talk about what you have done with <code>did:webvh</code>,</li> <li>share information about the <code>did:webvh</code> software you have written,</li> <li>tell us about the services you offer in deploying <code>did:webvh</code>, or</li> <li>anything else you can think of about <code>did:webvh</code>.</li> </ul> <p>The <code>did:webvh</code> information site is a MkDocs Material site generated from the Markdown files in the site's GitHub repository.</p> <p>Contributions can be mode via pull requests (PRs) to the GitHub repository that will be reviewed and (if relevant) merged. You can use the GitHub website itself to add or edit files, or fork the repo and edit them in your favorite GitHub-friendly editor.  Each commit of a PR must have a DCO (Developer Certificate of Origin - https://github.com/apps/dco) sign-off -- handled automagically on the GitHub website or, if done from the command line, by adding the <code>-s</code> (lower case) option on the <code>git commit</code> command (e.g., <code>git commit -s -m \"Comment about the commit\"</code>).</p> <p>If you are running locally and want to test your changes before creating your pull request, you must install and run <code>mkdocs</code>. Guidance for that can be found in the MkDocs Material documentation. Once it is installed, run <code>mkdocs</code> from the root folder and open your browser to the indicated site.</p>"},{"location":"specification/","title":"The <code>did:webvh</code> DID Method Specification","text":"<p>Here is a live version of the <code>did:webvh</code> specification. You probably want to open up a new browser window to see the published spec, but if you just want to scan some things -- here you go!</p>"},{"location":"version/","title":"Release Notes","text":""},{"location":"version/#didwebvh-version-changelog","title":"<code>did:webvh</code> Version Changelog","text":"<p>The following lists the substantive changes in each version of the specification, as included in the specification.</p>"},{"location":"whois/","title":"The <code>/whois</code> Use Case","text":"<p>This DID Method introduces what we hope will be a widely embraced convention for all DID Methods -- the <code>/whois</code> path. This feature harkens back to the <code>WHOIS</code> protocol that was created in the 1970s to provide a directory about people and entities in the early days of ARPANET. In the 80's, <code>whois</code> evolved into RFC920 that has expanded into the global whois feature we know today as RFC3912. Submit a <code>whois</code> request about a domain name, and get back the information published about that domain.</p> <p>We propose that the <code>/whois</code> path for a DID enable a comparable, decentralized, version of the <code>WHOIS</code> protocol for DIDs. Notably, when <code>&lt;did&gt;/whois</code> is resolved (using a standard DID <code>service</code> that follows the Linked-VP specification), a Verifiable Presentation (VP) may be returned (if published by the DID Controller) containing Verifiable Credentials with the DID as the <code>credentialSubject</code>, and the VP signed by the DID. Given a DID, one can gather verifiable data about the DID Controller by resolving <code>&lt;did&gt;/whois</code> and processing the returned VP. That's powerful -- an efficient, highly decentralized, trust registry. For <code>did:webvh</code>, the approach is very simple -- transform the DID to its HTTPS equivalent, and execute a <code>GET &lt;https&gt;/whois</code>. Need to know who issued the VCs in the VP? Get the issuer DIDs from those VCs, and resolve <code>&lt;issuer did&gt;/whois</code> for each. This is comparable to walking a CA (Certificate Authority) hierarchy, but self-managed by the DID Controllers -- and the issuers that attest to them.</p> <p>The following is a use case for the <code>/whois</code> capability. Consider an example of the <code>did:webvh</code> controller being a mining company that has exported a shipment and created a \"Product Passport\" Verifiable Credential with information about the shipment. A country importing the shipment (the Importer) might want to know more about the issuer of the VC, and hence, the details of the shipment. They resolve the <code>&lt;did&gt;/whois</code> of the entity and get back a Verifiable Presentation about that DID. It might contain:</p> <ul> <li>A verifiable credential issued by the Legal Entity Registrar for the   jurisdiction in which the mining company is headquartered.</li> <li>Since the Importer knows about the Legal Entity Registrar, they can automate     this lookup to get more information about the company from the VC -- its     legal name, when it was registered, contact information, etc.</li> <li>A verifiable credential for a \"Mining Permit\" issued by the mining authority   for the jurisdiction in which the company operates.</li> <li>Perhaps the Importer does not know about the mining authority for that     jurisdiction. The Importer can repeat the <code>/whois</code> resolution process for     the issuer of that credential. The Importer might (for example), resolve     and verify the <code>did:webvh</code> DID for the Authority, and then resolve the     <code>/whois</code> DID URL to find a verifiable credential issued by the government of     the jurisdiction. The Importer recognizes and trusts that government's     authority, and so can decide to recognize and trust the mining permit     authority.</li> <li>A verifiable credential about the auditing of the mining practices of the   mining company. Again, the Importer doesn't know about the issuer of the audit   VC, so they resolve the <code>/whois</code> for the DID of the issuer, get its VP and   find that it is accredited to audit mining companies by the London Metal   Exchange according to one of its mining standards.   As the Importer knows about both the London Metal Exchange and the standard,   it can make a trust decision about the original Product Passport Verifiable   Credential.</li> </ul> <p>Such checks can all be done with a handful of HTTPS requests and the processing of the DIDs and verifiable presentations. If the system cannot automatically make a trust decision, lots of information has been quickly collected that can be passed to a person to make such a decision.</p> <p>The result is an efficient, verifiable, credential-based, decentralized, multi-domain trust registry, empowering individuals and organizations to verify the authenticity and legitimacy of DIDs. The convention promotes a decentralized trust model where trust is established through cryptographic verification rather than reliance on centralized authorities. By enabling anyone to access and validate the information associated with a DID, the \"/whois\" path contributes to the overall security and integrity of decentralized networks.</p>"},{"location":"demos/","title":"Demos","text":"<p>We'll be adding demos and tutorials to this section soon!</p> <p>Stay tuned!</p>"},{"location":"implementers-guide/","title":"The <code>did:webvh</code> Implementer's Guide","text":"<p>This series of articles shares insights from developers and deployers of Trust DID Web (<code>did:webvh</code>), highlighting lessons learned from real-world deployments and use cases. </p> <p>The guide explores the features of <code>did:webvh</code>, how to deploy them, what\u2019s covered in the specification versus what implementers need to handle, provides pointers to existing implementations, and more.</p> <p>Contributions to the guide are welcome! If you have learned something about deploying did:webvh and want to share -- open an issue, or submit a pull request to add an article. If you do add an article, make sure you put a link to your new article in the <code>mkdocs.yml</code> file in the root of the didwebvh-info repository (or we are happy to do it for you...).</p>"},{"location":"implementers-guide/did-portability/","title":"DID Portability","text":"<p>As noted in the DID Portability section of the specification, a <code>did:webvh</code> DID can be renamed (ported) by changing the <code>id</code> DID string in the DIDDoc to one that resolves to a different HTTPS URL, as long as the specified conditions are met.</p> <p>While the impact of the feature is in fact the creation of a new DID, we think there is significant value in some use cases for supporting the specified capability. Ideally, the HTTPS URL for the \"old\" DID is changed to a redirect to the new DID, allowing for a seamless, verifiable evolution of the DID.</p> <p>An interesting example use case is a DID that replaces an email address hosted by a particular service. The extra capabilities of having the identifier being a DID vs. an email address is compelling enough, allowing it to be used for a range of services beyond email. The portability benefit comes when the owner of the DID decides to move to a new service, taking their DID with them. The verifiable history carried over to the renamed DID hosted by the new service provides assurance to those who interacted with the old DID (through chats, emails, postings, etc.) that they are still engaging with the same entity, despite the DID renaming. Compare that with what happens today when you switch from one email provider to another, and you have to reach out to all your contacts to assure them that you changed providers.</p> <p>While portability is powerful, it must be used with care and only in use cases where the capability is specifically required. When used, both the pre-rotation and witnesses features of <code>did:webvh</code> SHOULD also be enabled.</p>"},{"location":"implementers-guide/did-portability/#mergers-acquisitions-and-name-changes","title":"Mergers, Acquisitions and Name Changes","text":"<p>Organizations change over time and such changes often involve names changes. Name changes in turn trigger domain name changes, as organizations match their Web location with their names. Mergers, acquisitions, and simple name changes, all can cause an organization's \"known\" domain name to change, including the relinquishment of control over their previous domain name. When such changes occur, it is very unlikely that just because the organization's DIDs use the old domain name will prevent the changes. Thus the DIDs need to \"adapt\" to the new domain -- the domain name portion of the DID has to change. Ideally, the old location and domain can be retained and a web redirect used to resolve the old DID to the new, but even if that cannot be done, the ability to use the same SCID and retain the full history can be preserved.</p>"},{"location":"implementers-guide/did-portability/#did-hosting-service-providers","title":"DID Hosting Service Providers","text":"<p>Consider being able to replace the current identifiers we are given (email addresses, phone numbers) with <code>did:webvh</code> DIDs. Comparable hosting platforms might publish our DIDs for us (ideally, with us in custody of our own private keys...). Those DIDs, with the inherent public keys can be used for many purposes -- encrypted email (hello PGP!), messaging, secure file sharing, and more.</p> <p>From time to time in that imagined future, we may want to move our DIDs from one hosting service to another, just as we move from one email or mobile provider to another. With DIDs that can move and retain the history, we can make such moves smoothly. Contacts will see the change, but also see that the history of the DID remains.</p>"},{"location":"implementers-guide/did-portability/#challenges-in-moving-a-did","title":"Challenges in Moving a DID","text":"<p>While we see great value (and even a hard requirement) for being able to move a DID's web location, it does create challenges in aligning with the DID Core specification. These challenges are listed below.</p> <p>Moving a <code>did:webvh</code> is actually the (partial or complete) deactivation of the old DID and the creation of a new DID. The use of the SCID and the way it is generated is designed to prevent an attacker from being able to create a DID they control but with the same SCID as existing DID. Thus, \"finding\" a <code>did:webvh</code> with the same SCID implies the DIDs are the same. That can be verified by processing the DID Log.</p> <p>By retaining the incrementing of the <code>versionId</code> after a move, the \"new\" DID does not start at <code>versionId</code> of <code>1</code>. Further, resolving <code>&lt;new-did&gt;?versionId=1</code> is going to return a DIDDoc with the top-level <code>id</code> equal to the <code>&lt;old-did&gt;</code>. This is useful from a business perspective, but unexpected from a DID Core perspective.</p>"},{"location":"implementers-guide/did-valid-keys/","title":"What Are A DID's Valid Keys?","text":""},{"location":"implementers-guide/did-valid-keys/#problem-statement","title":"Problem Statement","text":"<p>We want the following all to be supported by DIDs in general, and <code>did:Webvh</code> DIDs in particular.</p> <ul> <li>DIDs to last a long time (decades).</li> <li>To be able to verify signatures on old documents.</li> <li>To be able to flag/prevent the use of known compromised keys for verification.</li> <li>Regularly rotate to new signing keys.</li> </ul> <p>What is the best way to indicate in <code>did:webvh</code> that a key is valid for use in verifying signature, even if it is no longer being used to create new signatures? Related, what is the best way to indicate that a key is invalid and SHOULD NOT be used for verifying a signature, and that a document containing a signature signed by that key should be discarded?</p> <p>Given that in <code>did:webvh</code>, it is easy to get the full history of the DIDs, and all the keys that have been in all versions of the DIDDoc, do we need to have all the valid keys in the current DIDDoc?</p> <p>This article explores these questions.</p>"},{"location":"implementers-guide/did-valid-keys/#best-practices-current-state-of-did-document-represents-all-valid-keys","title":"Best Practices: Current state of DID Document represents all valid keys","text":"<p>The current state of the DID Document MUST reflect all valid keys.</p> <p>Keys that are no longer valid MUST be promptly removed from the DID Document.</p> <p>The DID Controller determines when keys are considered valid.</p> <p>The DID Controller SHOULD establish policies that outline key rotation and expiration, according to best practices outlined by organizations like OWASP.</p> <p>The DID Controller SHOULD establish policies outlining key retention. Several factors influence key retention. The DID Controller should consider the following:</p> <ul> <li>Keys used to sign credentials (i.e. Verification Methods referenced or declared in the Assertion Method Verification Relationship) directly impact the validity of those credentials; if the key is not found in the Issuer's DID Document, the credential will fail verification. The frequency of key rotation and expiration may limit holder's ability to use these credentials.</li> <li>Keys used for other purposes (Authentication, Key Agreement, Capability Invocation, Capability Delegation) may be rotated more frequently without negatively impacting holders of credentials issued by the DID Controller.</li> </ul> <p>Key rotation, expiration, and retention policies are opaque to entities resolving the DID Document; all changes are enacted using standard CRUD operations by the DID Controller and the final state reflects the set of currently valid keys. Out-of-band key revocation checks MUST NOT be required.</p>"},{"location":"implementers-guide/did-valid-keys/#example","title":"Example","text":"<p>Consider a DID Controller that has a key rotation policy dictating that keys used for signing credentials are rotated annually and rotated keys are retained for a minimum of 5 years unless compromised. The current state of the DID Document's <code>assertionMethod</code> verification relationship would typically include 5 keys:</p> <ul> <li>the current key to be used for issuance,</li> <li>as well as the keys used for the previous 4 years,</li> <li>excepting any that had been compromised and removed before expiration.</li> </ul> <p>The DID Controller also has a key rotation policy dictating that keys used for authentication are rotated every 90 days and are expired immediately upon rotation. The current state of the DID Document's <code>authentication</code> verification relationship would include only the current key.</p>"},{"location":"implementers-guide/did-valid-keys/#reasoning","title":"Reasoning","text":"<p><code>did:webvh</code> (along with other DID Methods with a verifiable history) has the ability to resolve the state of a DID Document at a point in the past. It is tempting to use this ability to provide point-in-time key references when signing credentials, enabling a credential signed by that key to be valid indefinitely while also not needing to worry about keeping that key in the current state of the DID Document. However, this point-in-time resolution provides no data about whether the validity of the key has changed since that point in time. The DID Controller would have to rewrite the history of the DID Document to annotate the key as revoked or provide some alternate, out-of-band mechanism for checking for revoked keys.</p> <p>This point-in-time key reference creates a false positive by default during credential verification; a naive verifier would resolve the key material and \"successfully\" verify the credential without realizing that the key is potentially in the hands of an impersonator or is otherwise unfit for use. This places the burden of checking for up-to-date information on the verifier while also introducing additional complexity for both the issuer and the verifier.</p> <p>Note</p> <p>It is possible that <code>did:webvh</code> specification could specify that a key defined in an earlier DID version is revoked, requiring that any attempt to resolve that key (by <code>versionId</code> and <code>#fragment</code>) return a suitable error (e.g., <code>KEY-REVOKED</code>). The burden is still on the resolver to check for revocation, and only non-compliant resolvers would be a problem.</p> <p>Using the current state of the DID Document to reflect all valid keys, by contrast, creates a false negative by default; a naive verifier cannot verify a credential that does not have key material present in the current state of the DID Document. This false negative by default is the safer approach, effectively eliminating the possibility that the verifier may have used compromised key material to verify a credential. This places the burden of providing up to date information on the issuer, which is the most suitable party to be responsible for it.</p> <p>Note</p> <p>The impact of this requirement is that despite having the full history of the DID, we have to repeat the (growing) list of valid keys in each DID version, making the DID Log much larger. The DID Log would be smaller if we had a method of defining the key once and revoking it when necessary. At this time, we don't have that mechanism. The discussion below of using JSON Patch could mitigate the DID Log size issue.</p> <p>However, the verifier still has the ability to incorporate historical data; upon finding that the credential failed to verify with the current set of keys, a sophisticated verifier can look up the state of the DID Document at the point-in-time at which the credential was issued (or some other relevant time frame). The verifier can use this additional information to make more nuanced decisions about the result of the presentation and how to act on it.</p>"},{"location":"implementers-guide/did-valid-keys/#potential-future-optimization","title":"Potential Future Optimization","text":"<p>Previous versions of the <code>did:webvh</code> used JSON Patch to construct a DID Document by layering changes. The intent was to keep the size of the history down. It was later decided that this was an unneeded optimization. Several examples of DID Documents were examined and it was found that just using the full state of the DID Document rather than using JSON Patches was often smaller.</p> <p>While taking into account the need for key rotation and the practices outlined here, we may find need to optimize for size again in the future by reintroducing JSON Patch.</p>"},{"location":"implementers-guide/high-assurance-dids-with-dns/","title":"Using High Assurance DIDs with DNS","text":"<p>The High Assurance DIDs with DNS mechanism that can be used with <code>did:web</code> applies equally well with <code>did:webvh</code>.  A DID Controller publishing a <code>did:webvh</code> could use the mechanisms defined in the High Assurance DIDs with DNS specification despite <code>did:webvh</code> DIDs not (yet) being explicitly called out in the High Assurance DIDs with DNS specification. In particular, as <code>did:webvh</code> uses the same DID-to-HTTP transformation, publishing the expected DNS Domain records, and adding the required verification method and Data Integrity proof to their DIDDoc is done as defined in the High Assurance DIDs with DNS specification. Likewise, a resolver can include code to check to see if the DID Controller published the High Assurance DIDs with DNS specification DNS records and use those to further verify the DID.</p> <p>Alternatively, since <code>did:webvh</code> is not mentioned in the High Assurance DIDs with DNS specification, a <code>did:webvh</code> DID Controller could use the \"not <code>did:web</code>\" technique described in that specification and include a <code>dnsValidationDomain</code> entry in the DIDDoc to explicitly denote where to find the DNS records to use in binding the DID to the DNS domain. This technique could also be used with <code>did:webvh</code> (and <code>did:web</code> for that matter) if the DID is published on a platform (such as GitHub) and the controller wants to bind it to its DNS domain.</p>"},{"location":"implementers-guide/high-assurance-dids-with-dns/#future-possibilities","title":"Future Possibilities","text":"<p>In the future, as <code>did:webvh</code> becomes more accepted, we would like to see <code>did:webvh</code> explicitly added to the High Assurance DIDs with DNS specification beside <code>did:web</code>.</p> <p>Since <code>did:webvh</code> and the High Assurance DIDs with DNS specification both have the goal of adding methods for additional verifications of the DID, the support for <code>did:webvh</code> in the High Assurance DIDs with DNS could be more specific to the DID Method. For example, the key in the DNS record could be a required <code>did:webvh</code> witness, with its Data Integrity proof being a part of the DID log entry rather than in the DIDDoc itself.</p>"},{"location":"implementers-guide/prerotation-keys/","title":"Using Pre-Rotation Keys","text":"<p>In an effort to prevent the loss of control over a decentralized identifier (DID) due to a compromised private key, pre-rotation keys are introduced. These commitments, made by the DID Controller, are declarations about the authorization keys that will be published in future versions of the DID log, without revealing the keys themselves.</p> <p>The primary goal of pre-rotation keys is to ensure that even if an attacker gains access to the current active key, they will not be able to take control of the DID. This safeguard is achieved because the attacker could not simply rotate to a key they generate and control. Rather, they would need to have also compromised the unpublished (and presumably securely stored) pre-rotation key in order to rotate the DID keys.</p> <p>The cost of having pre-rotation protection is a more complicated process to update the keys of a DID. The following are some considerations we have come across in thinking about how to use the pre-rotation feature. The feature adds a layer of key management complexity in return for the benefit.</p>"},{"location":"implementers-guide/prerotation-keys/#key-rotation-with-pre-rotation","title":"Key Rotation with Pre-Rotation","text":"<p>In using pre-rotation, a DID Controller should generate an \"active\" key for the DIDDoc that is accessible for \"production\" purposes (signing, decrypting), and generates the \"next key\" in an isolated location from production. This prevents both the \"active\" and \"next key\" from being compromised in the same intrusion attack. For example, if an intruder gets into your infrastructure and is able to extract all of your private keys both DID control keys would be lost. Thus, we expect the feature to be used as follows:</p> <ul> <li>The DID Controller creating the DID would request from an isolated   service the hash of the \"next key\" as defined in this specification. For   example, an entity might have the \"active\" DID/key hosted by one Cloud   Provider, and the \"next key\" by another, on the theory that an attacker might   get into one environment or another but not both.</li> <li>When a key rotation is to be done, two entries are put in the log, using the following steps by the DID Controller:</li> <li>Get the full key reference entry from the isolated service for the pre-rotation \"nextKey\".</li> <li>Locally generate a pre-rotation key hash for a new key that will soon become the \"active\" key.</li> <li>Add a DID log entry that includes the properties from the previous two steps, and signs the proof using an authorized key (that presumably it controls, though not required).<ol> <li>Although the DID log could be published now, it is probably best to hold off and publish it after adding a second, as described by the rest of the steps.</li> </ol> </li> <li>Get a new pre-rotation hash from the isolated service.</li> <li>Get the full key-rotation key reference for the pre-rotation hash created for the last DID log entry.</li> <li>Add a DID Log entry that includes the properties from the previous two step</li> <li>If the key rotated in the previous DID log entry was a/the      authorized key to make updates to the DID, call the isolated service to produce      the Data Integrity proof over the entry using the key the isolated      service controls.<ol> <li>This step is not needed if the active service has a key authorized to sign the DIDDoc update.</li> </ol> </li> <li>Publish the new DID log containing the two new entries.</li> </ul>"},{"location":"implementers-guide/prerotation-keys/#post-quantum-attacks","title":"Post Quantum Attacks","text":"<p>One of the potential benefits of this approach to pre-rotation is that it is \"post-quantum safe\". The idea is that in a post-quantum world, the availability of the published key and signatures may enable the calculation of the corresponding private key. Since the pre-rotation value is a hash of the <code>nextKey</code> and not the public key itself, a post-quantum attack would not compromise that key, and so a further rotation by the attacker would not be possible. If there was a (suspected) need to transition to using a quantum-safe key, the same process listed above would be used, but key reference and the pre-rotation hash added into the second DID log entry would presumably both be for quantum-safe keys.</p>"},{"location":"implementers-guide/prerotation-keys/#challenges-in-using-pre-rotation","title":"Challenges in Using Pre-Rotation","text":"<p>Key management is hard enough without having to maintain isolated key generation environments for creating keys for different purposes. Enabling connectivity between the key generation environments to enable automated key rotation while maintaining the key recovery environment as \"isolated\" is technically challenging.</p>"},{"location":"implementers-guide/resolution-errors/","title":"<code>did:webvh</code> Resolution Error Codes","text":"<p>did:webvh Resolution Error Codes This page defines the set of structured error codes and messages used in <code>did:webvh</code> DID resolution metadata, specifically in the <code>problemDetails</code> field as defined by RFC 9457.</p>"},{"location":"implementers-guide/resolution-errors/#using-rfc-9457-in-didwebvh","title":"Using RFC 9457 in did:webvh","text":"<p>When DID resolution fails, <code>did:webvh</code> resolvers MUST return an <code>error</code> field in the <code>didResolutionMetadata</code>, as defined in the DID Resolution specification. To provide additional structured information, resolvers SHOULD include a <code>problemDetails</code> object conforming to RFC 9457. For example, the DID Resolution Metadata would look like this:</p> <pre><code>\"didResolutionMetadata\": {\n  \"error\": \"invalidDid\",\n  \"problemDetails\": {\n    \"type\": \"https://w3id.org/security#INVALID_CONTROLLED_IDENTIFIER_DOCUMENT_ID\",\n    \"title\": \"The resolved DID is invalid.\",\n    \"detail\": \"Parse error of the resolved DID at character 3, expected ':'.\"\n  }\n}\n</code></pre> <p>The <code>problemDetails</code> object includes the following fields:</p> <ul> <li><code>type</code>: A URI pointing to this page, with a fragment identifier representing the error code from the list below. For example: <code>https://didwebvh.info/main/resolution-errors/#did-log-id-mismatch</code></li> <li><code>title</code>: A human-readable title for the error, matching the one listed in the section for the corresponding error code below.</li> <li><code>detail</code>: A more specific message describing the error encountered, suitable for developers or technical users.</li> </ul> <p>The list of <code>title</code> and <code>detail</code> values collected by <code>did:webvh</code> resolver implementers is provided below.</p> <p>Resolver implementers SHOULD use the <code>type</code> and <code>title</code> values below and MAY use the <code>detail</code> or one appropriate for the implementation.</p>"},{"location":"implementers-guide/resolution-errors/#implementer-guidance","title":"Implementer Guidance","text":"<p>Resolver implementers should use the errors listed below as standardized codes for communicating resolution failures. If your resolver needs to report an error not listed here, you are encouraged to contribute to this list via a pull request to the did:webvh information site GitHub repository. Please ensure your proposed error includes:</p> <ul> <li>A clear and unique error code (used as the fragment in the <code>type</code> URI)</li> <li>A descriptive title</li> <li>A concise, developer-friendly detail message</li> </ul>"},{"location":"implementers-guide/resolution-errors/#resolution-error-codes","title":"Resolution Error Codes","text":""},{"location":"implementers-guide/resolution-errors/#did-log-id-mismatch","title":"did-log-id-mismatch","text":"<p>Title: DID Log for DID being resolved not found Detail: A DID Log File was found, but the <code>id</code> in the DIDDoc does not match the DID <code>${did}</code> being resolved.</p>"},{"location":"implementers-guide/resolution-errors/#conflicting-resolution-options","title":"conflicting-resolution-options","text":"<p>Title: Cannot specify both verificationMethod and version number/id Detail: Conflicting resolution options were provided in the resolution request.</p>"},{"location":"implementers-guide/resolution-errors/#unknown-protocol","title":"unknown-protocol","text":"<p>Title: Protocol unknown.  Detail: The protocol '${protocol}' in the DID Log File does not match the expected protocol.</p>"},{"location":"implementers-guide/resolution-errors/#version-mismatch","title":"version-mismatch","text":"<p>Title: Version number in log doesn't match expected  Detail: A DID log entry's version number '\\({version}' does not match the expected sequence '\\)'.</p>"},{"location":"implementers-guide/resolution-errors/#scid-verification-failed","title":"scid-verification-failed","text":"<p>Title: SCID not derived from logEntryHash Detail: SCID ('\\({meta.scid}') validation failed due to a mismatch in expected hash ('\\)').</p>"},{"location":"implementers-guide/resolution-errors/#proof-verification-failed","title":"proof-verification-failed","text":"<p>Title: Version failed verification of the proof Detail: The proof attached to the version (${meta.versionId}) log entry failed verification.</p>"},{"location":"implementers-guide/resolution-errors/#portability-disabled","title":"portability-disabled","text":"<p>Title: Cannot move DID: portability is disabled Detail: An attempt was made to move a DID, but portability is not enabled in the DID Log.</p>"},{"location":"implementers-guide/resolution-errors/#hash-chain-broken","title":"hash-chain-broken","text":"<p>Title: Hash chain broken Detail: The cryptographic hash chain was broken at version '${meta.versionId}'.</p>"},{"location":"implementers-guide/resolution-errors/#verification-method-not-found","title":"verification-method-not-found","text":"<p>Title: Verification method not found Detail: The verification method ${vm} could not be located in the DIDDoc or verification context.</p>"},{"location":"implementers-guide/resolution-errors/#verification-method-resolution-error","title":"verification-method-resolution-error","text":"<p>Title: Error resolving verification method Detail: A general error occurred while resolving the specified verification method ${vm}.</p>"},{"location":"implementers-guide/resolution-errors/#key-not-authorized-to-update","title":"key-not-authorized-to-update","text":"<p>Title: Key is not authorized to update Detail: The key ${proof.verificationMethod} used in the proof is not in the list of authorized update keys.</p>"},{"location":"implementers-guide/resolution-errors/#witness-key-not-authorized","title":"witness-key-not-authorized","text":"<p>Title: Key is not from an authorized witness Detail: The key ${proof.verificationMethod} used in the proof is not recognized as coming from an authorized witness.</p>"},{"location":"implementers-guide/resolver-algorithm/","title":"Implementing a <code>did:webvh</code> Resolver","text":"<p>This article summarizes the process that a <code>did:webvh</code> resolver might use in processing a <code>did:webvh</code> DID. The process covers both the DID Log File processing, as well as the processing of the DID Witness Proofs file (if applicable). This article is not a specification, and there is no requirement for a <code>did:webvh</code> to follow this approach. It is provided to help those beginning a registrar/resolver implementation to navigate the specification (links into the specification are embedded in the algorithm) using the experience of those that have gone before. Updates to the algorithm are welcome (via Issues or PRs) from implementers wanting to make life easier for those who will follow.</p> <p>This approach draws heavily from the <code>did:webvh</code> Python implementation at DIF.</p> <p>The verification passes below may be interleaved. In particular, the <code>did:webvh</code> Python implementation collects log entry proofs and verifies them in a thread pool in the background while doing the primary verification. Witness log retrieval could be performed when the first <code>witness</code> rule is seen in the DID Log.</p>"},{"location":"implementers-guide/resolver-algorithm/#primary-verification","title":"Primary verification","text":"<ul> <li>Fetch <code>did.jsonl</code> (Spec Ref). If not found, abort (<code>error=notFound</code>).</li> <li>For each entry in the history log:</li> <li>Perform preliminary checks:<ul> <li>Check the entry is a valid JSON object with only the required properties. (Spec Ref)</li> <li>If it is the first entry, check the SCID derivation. (Spec Ref)</li> <li>Check the derivation of the entry hash and the sequencing of the version number. (Spec Ref)</li> <li>Verify the DIDDoc ID contains the SCID.</li> <li>Verify the type, value, and validity (allowed or not) of the parameters in the Log Entry. (Spec Ref)</li> </ul> </li> <li>If preliminary checks fail:<ul> <li>Set <code>INVALID=true</code>.</li> <li>Move to the next verification phase.</li> </ul> </li> <li>If a specific <code>versionId</code> is specified:<ul> <li>If the requested <code>versionId</code> equals the current entry's <code>versionId</code>:</li> <li>If a specific <code>versionTime</code> is requested and is less than the entry's <code>versionTime</code>, abort (<code>error=notFound</code>) - cannot reconcile <code>versionId</code> and <code>versionTime</code>.</li> <li>Set <code>FOUND</code> to the current entry.</li> </ul> </li> <li>If a specific <code>versionTime</code> is requested and a specific <code>versionId</code> is not requested:<ul> <li>If the current entry's <code>versionTime</code> &lt;= <code>versionTime</code>:</li> <li>Set <code>FOUND</code> to the current entry.</li> </ul> </li> <li>If the current entry updates the parameters (Spec Ref) <code>updateKeys</code>, <code>nextKeyHashes</code>, or <code>witness</code>:<ul> <li>Add the entry to <code>AUTH_ENTRIES</code>.</li> </ul> </li> <li>If the <code>witness</code> parameter is non-null and the <code>threshold</code> is non-zero (Spec Ref):<ul> <li>Add <code>(versionNumber, witness)</code> to <code>WITNESS_CHECKS</code>.</li> </ul> </li> <li>If the previous value of <code>witness</code> was non-null and different from <code>witness</code>:<ul> <li>Add <code>(versionNumber, prevWitness)</code> to <code>WITNESS_CHECKS</code>.</li> </ul> </li> <li>Add the current entry's <code>versionId</code> to <code>CHECKED</code>.</li> <li>Set <code>LATEST</code> to the current entry.</li> </ul>"},{"location":"implementers-guide/resolver-algorithm/#proof-verification","title":"Proof verification","text":"<ul> <li>If <code>LATEST</code> is not set, abort (<code>error=invalidDid</code>) - no entries.</li> <li>If <code>FOUND</code> is not set:</li> <li>If <code>INVALID</code>, abort (<code>error=invalidDid</code>) - latest version is needed, but verification short-circuited.</li> <li>If a specific <code>versionId</code> or <code>versionTime</code> is requested, abort (<code>error=notFound</code>).</li> <li>Set <code>FOUND=LATEST</code>.</li> <li>Add <code>FOUND</code> to <code>AUTH_ENTRIES</code>.</li> <li>For each entry in <code>AUTH_ENTRIES</code>:</li> <li>Check the associated entry proof(s). There must be at least one valid proof from an active update key. (Define active keys) (Spec Ref)</li> <li>If no valid proof is found, abort (<code>error=invalidDid</code>).</li> </ul>"},{"location":"implementers-guide/resolver-algorithm/#witness-verification","title":"Witness verification","text":"<ul> <li>If <code>WITNESS_CHECKS</code> is not set, then skip to next verification phase.</li> <li>Fetch <code>did-witness.json</code>. If not found, abort (<code>error=invalidDid</code>). (Spec Ref)</li> <li>For each proof in the log:</li> <li>Check the <code>versionId</code> is set and is in <code>CHECKED</code>, otherwise skip.</li> <li>Check the validity of the proof, otherwise skip.</li> <li>Extract the version number from the <code>versionId</code>.</li> <li>Add <code>(versionNumber, witnessId)</code> to <code>WITNESS_VALID</code>.</li> <li>For each <code>(versionNumber, rule)</code> in <code>WITNESS_CHECKS</code>:</li> <li>Check the witness rule against <code>WITNESS_VALID</code>. Each entry with a later <code>versionNumber</code> and one of the requested witness IDs may add to the weight. (Don't count multiple proofs from the same witness ID.)</li> <li>If the threshold of a rule is met, remove it from <code>WITNESS_CHECKS</code>. (Spec Ref)</li> <li>If any values remain in <code>WITNESS_CHECKS</code>, abort <code>(error=invalidDid)</code>.</li> </ul>"},{"location":"implementers-guide/resolver-algorithm/#final-checks","title":"Final checks","text":"<ul> <li>For the resolved entry <code>FOUND</code>, check that the ID of the document matches the resolution target.</li> <li>If not, abort (<code>error=notFound</code>).</li> <li>Add implicit services (<code>#files</code> / <code>#whois</code>) to the DID document as needed. (Spec Ref Files), (Spec Ref Whois)</li> <li>Perform dereferencing if necessary.</li> <li>If <code>INVALID</code> is set, add (TBD) to the resolution metadata. Adjust the internal TTL to the standard 'verification failure' TTL.</li> </ul> <p>TODO: define caching behavior</p>"},{"location":"implementers-guide/witnesses/","title":"Witnesses","text":"<p>The term \"witness\" is often used in the decentralized trust space to refer to participants in an ecosystem that oversee the evolution of an identifier according to some ecosystem-specific governance framework. The goal is for a witness to collect, verify and approve data about the identifier and share it with others that trust the witness so they don't need to do that work themselves. The extra participants are intended to identify both malicious attackers of the identifier, and malicious use of the identifier by the DID Controller.</p> <p>Witnesses play an explicit function in <code>did:webvh</code>. When used by a DID Controller, witnesses (themselves identified by DIDs) are sent pending DID log entries prepared by the DID Controller. The witnesses verify the log entry using their copy of the \"current state\" of the DID, and then \"approve\" the update, according to the governance they use to define what \"approval\" means. For example, a [[ref: witness might interact with another party (perhaps even a person) to confirm that the DID Controller created the log entry. Once the [[ref: witness has both verified and approved the change, they express that approval by creating a Data Integrity proof that is chained to the data integrity proof created by the DID Controller, and send the proof back to the DID Controller. Once the number of data integrity proofs received by the DID Controller from the witnesses has exceeded a threshold, the DID Controller adds those proofs to their own data integrity proof in the log entry. Next, the DID Controller adds the log entry to the DID log and publishes the updated DIDDoc. A DID Controller relying on witnesses cannot independently publish an update to their DID -- they must get and publish the witness approval proofs.</p> <p>The application of witnesses is very much dependent on the governance of the ecosystem. Such governance is outside the scope of the <code>did:webvh</code> specification, and up to those deploying <code>did:webvh</code> DIDs. Hence, a DID Controller that controls a series of DIDs and uses those DIDs as [[ref: witnesses adds no additional trust or security to a DID if no properly defined governance is in place. In particular, in order for witnesses to add security and trust to a DID requires the members of an ecosystem to agree to the defined governance. A witness could be an \"endorser\" of a set of DIDs that are part of an ecosystem, with the act of witnessing the updates conveying through their approval that the DIDs are a legitimate participant in the ecosystem. Witnesses can also be used as a form of \"two-factor authentication\" of a change, such as having a public key published as a DNS record used as a witness for the DID. Such an addition means that an attacker would need to compromise both the web-publishing infrastructure of the DID Controller (where they publish the DID's <code>did.jsonl</code> file) as well as its DNS entry.</p> <p><code>did:webvh</code> witnesses have been specified to be simple to implement and use. Their power and effectiveness will come in how they are deployed within specific, governed ecosystems.</p>"}]}